I"îB<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand and explain the Lookup Chain and how it relates to the principle of Polymorphism in Object-Oriented Programming.</li>
  <li>Explore how Ruby‚Äôs object model facilitates this principle.</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>

<ul>
  <li>Inheritance</li>
  <li>Polymorphism</li>
  <li>Superclass</li>
  <li>Module</li>
  <li>Object Model</li>
  <li>Lookup Chain</li>
</ul>

<h2 id="warmup">WarmUp</h2>

<ul>
  <li>What is class inheritance and how is it implemented in Ruby?</li>
  <li>What is a module in Ruby and how is it implemented?</li>
  <li>How do you know what variables, methods, and classes you have available at any given time in Ruby?</li>
</ul>

<h1 id="the-ruby-object-model">The Ruby Object Model</h1>

<h2 id="investigative-methods">Investigative Methods</h2>

<p>These three methods can help you investigate the relationships between classes and modules in Ruby. All methods are run on the class (i.e., <code class="language-plaintext highlighter-rouge">String.ancestors</code>, <code class="language-plaintext highlighter-rouge">Hash.included_modules</code>):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.ancestors</code>: lists all classes along the inheritance chain, and any modules included by those classes.</li>
  <li><code class="language-plaintext highlighter-rouge">.included_modules</code>: returns a list of all modules included by any class along the inheritance chain.</li>
  <li><code class="language-plaintext highlighter-rouge">.superclass</code>: returns the superclass of the class.</li>
</ul>

<h2 id="mapping-rubys-object-model">Mapping Ruby‚Äôs Object Model</h2>

<h3 id="superclasses">Superclasses</h3>

<p>We are going to create a <code class="language-plaintext highlighter-rouge">Dog</code> class that inherits from another class called <code class="language-plaintext highlighter-rouge">Animal</code>, which includes a module called <code class="language-plaintext highlighter-rouge">AnimalBehavior</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># dog.rb</span>
<span class="nb">require</span> <span class="s1">'./animal'</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">&lt;</span> <span class="no">Animal</span>
<span class="k">end</span>

<span class="n">dog</span> <span class="o">=</span> <span class="no">Dog</span><span class="p">.</span><span class="nf">new</span>
<span class="nb">require</span> <span class="s1">'pry'</span><span class="p">;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">pry</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># animal.rb</span>
<span class="nb">require</span> <span class="s1">'./animal_behavior'</span>

<span class="k">class</span> <span class="nc">Animal</span>
  <span class="kp">include</span> <span class="no">AnimalBehavior</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># animal_behavior.rb</span>
<span class="k">module</span> <span class="nn">AnimalBehavior</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Notice that we haven‚Äôt actually included any methods in these classes/modules. We don‚Äôt need them to map Ruby‚Äôs Object Model.</p>

<p>When we run the <code class="language-plaintext highlighter-rouge">dog.rb</code> file, we create a new instance of <code class="language-plaintext highlighter-rouge">Dog</code> and then hit a pry. Using the investigative methods we defined above, we can learn about that dog instance‚Äôs ancestors:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dog</span>
<span class="c1"># =&gt; #&lt;Dog:0x007ff414932eb0&gt;</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dog</span><span class="p">.</span><span class="nf">class</span>
<span class="c1"># =&gt; Dog</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Dog</span><span class="p">.</span><span class="nf">ancestors</span>
<span class="c1"># =&gt; [Dog, Animal, AnimalBehavior, Object, PP::ObjectMixin, Kernel, BasicObject]</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Dog</span><span class="p">.</span><span class="nf">superclass</span>
<span class="c1"># =&gt; Animal</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Animal</span><span class="p">.</span><span class="nf">superclass</span>
<span class="c1"># =&gt; Object</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Object</span><span class="p">.</span><span class="nf">superclass</span>
<span class="c1"># =&gt; BasicObject</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">BasicObject</span><span class="p">.</span><span class="nf">superclass</span>
<span class="c1"># =&gt; nil</span>
</code></pre></div></div>

<p>Calling <code class="language-plaintext highlighter-rouge">.class</code> on the Dog object leads us to the <code class="language-plaintext highlighter-rouge">Dog</code> class. Calling <code class="language-plaintext highlighter-rouge">.superclass</code> on the <code class="language-plaintext highlighter-rouge">Dog</code> class leads us to <code class="language-plaintext highlighter-rouge">Object</code>, and calling <code class="language-plaintext highlighter-rouge">superclass</code> on <code class="language-plaintext highlighter-rouge">Object</code> leads us to <code class="language-plaintext highlighter-rouge">BasicObject</code>. <code class="language-plaintext highlighter-rouge">BasicObject</code> has no superclass, so the inheritance chain ends there. We can summarize this information in a diagram:</p>

<p><img src="../../assets/images/lessons/lookup_chain/dog_inheritance.png" alt="Dog Inheritance" /></p>

<p>Notice how we have included two instances of Dog in this diagram. This is to illustrate that there can be many instances of a class, and they all have a <code class="language-plaintext highlighter-rouge">.class</code> pointer to their Class. In this example, there can be many instances of Dog that all have the same <code class="language-plaintext highlighter-rouge">Dog</code> class.</p>

<p>Also notice that we call <code class="language-plaintext highlighter-rouge">.superclass</code> on the <code class="language-plaintext highlighter-rouge">Dog</code> class, not the dog instance. What happens if we call <code class="language-plaintext highlighter-rouge">.superclass</code> on a dog instance? Try it to find out.</p>

<p>Because our class inherits from <code class="language-plaintext highlighter-rouge">Object</code>, which inherits from <code class="language-plaintext highlighter-rouge">BasicObject</code>, we know that any class we create will have those two ancestors. This is where <code class="language-plaintext highlighter-rouge">:new</code> comes from. Look in the <a href="https://ruby-doc.org/core-3.0.0/BasicObject.html">Ruby Docs BasicObject Page</a> and you‚Äôll see the <code class="language-plaintext highlighter-rouge">:new</code> defined there.</p>

<section class="dropdown">

  <h3 id="here-is-how-you-might-implement-a-similar-structure-in-javascript">Here is how you might implement a similar structure in JavaScript</h3>

  <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="p">();</span>
<span class="nx">dog</span> <span class="k">instanceof</span> <span class="nx">Animal</span><span class="p">;</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nf">getPrototypeOf</span><span class="p">(</span><span class="nx">Dog</span><span class="p">);</span> <span class="c1">// Animal</span>
</code></pre></div>  </div>

</section>

<h3 id="mixins-and-modules">Mixins and Modules</h3>

<p>We‚Äôve mapped out the inheritance chain for our dog, but what about the modules? What happens if we call <code class="language-plaintext highlighter-rouge">included_modules</code> on our <code class="language-plaintext highlighter-rouge">Dog</code> class.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Dog</span><span class="p">.</span><span class="nf">included_modules</span>
<span class="c1">#=&gt; [AnimalBehavior, PP::ObjectMixin, Kernel]</span>
</code></pre></div></div>

<p>We can see our <code class="language-plaintext highlighter-rouge">AnimalBehavior</code> module (along with some others), but we included that in <code class="language-plaintext highlighter-rouge">Animal</code>, not in <code class="language-plaintext highlighter-rouge">Dog</code>, so why is it showing up here? <code class="language-plaintext highlighter-rouge">included_modules</code> shows all modules that were included in <em>any</em> superclass, so it won‚Äôt tell us <strong>where</strong> that module was included. In this case, we get more information if we start at the top of the inheritance chain to figure out where modules first appear (you may get slightly different results depending on what Ruby version you are running):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">BasicObject</span><span class="p">.</span><span class="nf">included_modules</span>
<span class="c1"># =&gt; []</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Object</span><span class="p">.</span><span class="nf">included_modules</span>
<span class="c1"># =&gt; [PP::ObjectMixin, Kernel]</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Animal</span><span class="p">.</span><span class="nf">included_modules</span>
<span class="c1"># =&gt; [AnimalBehavior, PP::ObjectMixin, Kernel]</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Dog</span><span class="p">.</span><span class="nf">included_modules</span>
<span class="c1"># =&gt; [AnimalBehavior, PP::ObjectMixin, Kernel]</span>
</code></pre></div></div>

<p>From this information, we can deduce that <code class="language-plaintext highlighter-rouge">BasicObject</code> doesn‚Äôt include any modules, <code class="language-plaintext highlighter-rouge">Object</code> includes <code class="language-plaintext highlighter-rouge">PP:ObjectMixin</code> and <code class="language-plaintext highlighter-rouge">Kernel</code> (you don‚Äôt need to worry about what those are), and <code class="language-plaintext highlighter-rouge">Animal</code> includes <code class="language-plaintext highlighter-rouge">AnimalBehavior</code>.</p>

<p>Our updated diagram:</p>

<p><img src="../../assets/images/lessons/lookup_chain/dog_inheritance_final.png" alt="Imgur" /></p>

<section class="note">

  <h3 id="note">Note</h3>

  <p>JavaScript does not have native support for mixins within its class system.</p>

</section>

<h2 id="chart-exercise">Chart Exercise</h2>

<p>Using <code class="language-plaintext highlighter-rouge">.class</code>, <code class="language-plaintext highlighter-rouge">.ancestors</code>, <code class="language-plaintext highlighter-rouge">.included_modules</code>, and <code class="language-plaintext highlighter-rouge">.superclass</code>, diagram the Object Model of these several commonly-used Ruby classes: Hash, Array, String, Integer, and Float.</p>

<p>Feel free to collaborate with cohort mates!</p>

<h1 id="the-lookup-chain-and-polymorphism">The Lookup Chain and Polymorphism</h1>

<p>In programming, polymorphism lets us use the same method or property in different classes or objects. Each class or object can have its own special version of a method through a process called <strong>method overriding</strong>, where a local definition of a method overrides the same method from the parent class.</p>

<section class="note">

  <h3 id="note-1">Note</h3>

  <p>Another form of polymorphism is <strong>method overloading</strong>, which allows you to create multiple versions of the same method, each with different parameters. Contrary to method overriding, an overloaded method can live in the same class. Neither Ruby nor JavaScript support method overloading.</p>

</section>

<p>We now have a mental model for how Ruby manages classes, instances, superclasses, and modules, but why does it matter? The biggest implication of the Object Model is the <strong>Lookup Chain</strong>. We know that we can store methods in several places (class, superclass, module), but what is the exact order that Ruby looks for things? If a method is defined in several places, which one will Ruby use?</p>

<p>Understanding the Lookup Chain is crucial for mastering Polymorphism in Software Development. This chain determines the method resolution path when a method is called on an object and what should happen if that method is not found directly on the object.</p>

<section class="note">

  <h3 id="note-2">Note</h3>

  <p>In JavaScript, the <strong>prototype chain</strong> plays a similar role to Ruby‚Äôs Lookup Chain, affecting how methods and properties are accessed and overridden.</p>

</section>

<h2 id="lookup-chain-exercise">Lookup Chain Exercise</h2>

<p>Complete <a href="https://github.com/turingschool-examples/se-mod1-exercises/tree/main/lessons/ruby_object_model/lookup_chain_exercise">this activity</a>. In the first part of the activity, you will map the Object Model for a <code class="language-plaintext highlighter-rouge">Chair</code> instance, just as we did above. Then you will alter the code to explore the order of the Lookup Chain.</p>

<p>Once you have finished the activity, write out the order of the Lookup Chain as concisely as possible.</p>

<h2 id="other-definitions-and-rules">Other Definitions and Rules</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Classes</code>
    <ul>
      <li>Store instance methods, have a <code class="language-plaintext highlighter-rouge">.superclass</code> pointer</li>
      <li>Are also instances (of the <code class="language-plaintext highlighter-rouge">Class</code> class)</li>
      <li>Can only directly inherit from one other class (its ‚Äòsuperclass‚Äô)</li>
      <li>Can include multiple Modules.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Instances</code>
    <ul>
      <li>Store instance variables, have a <code class="language-plaintext highlighter-rouge">.class</code> pointer</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Modules</code>
    <ul>
      <li>Can be mixed-in to multiple classes (mixins)</li>
    </ul>
  </li>
</ul>

<h2 id="wrap-up">Wrap Up</h2>

<ul>
  <li>How does Ruby‚Äôs lookup chain work? What is the order it checks things?</li>
  <li>What are three methods you can use to learn about where a built-in Ruby method gets its components?</li>
  <li>Draw a diagram of where Ruby would look for the method <code class="language-plaintext highlighter-rouge">::new</code></li>
</ul>

<h2 id="additional-resources">Additional Resources</h2>

<ul>
  <li><a href="https://www.sitepoint.com/understanding-object-model/">‚ÄúUnderstanding the Object Model.‚Äù</a></li>
  <li><a href="https://vimeo.com/160952993">Ruby Object Model Video</a></li>
</ul>
:ET